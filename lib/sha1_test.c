/*
 *	BIRD Library -- SHA-1 and HMAC-SHA-1 Tests
 *
 *	(c) 2015 CZ.NIC z.s.p.o.
 *
 *	Can be freely distributed and used under the terms of the GNU GPL.
 */

#include <stdlib.h>

#include "test/birdtest.h"
#include "sysdep/config.h"
#include "lib/sha1.h"


static void
get_sha1(const char *str, char (*out_hash)[SHA1_HEX_SIZE])
{
  struct sha1_context ctx;
  sha1_init(&ctx);
  sha1_update(&ctx, str, strlen(str));
  byte *hash = sha1_final(&ctx);

  int i;
  for(i = 0; i < SHA1_SIZE; i++)
    sprintf(*out_hash + i*2, "%02x", hash[i]);
}

static int
t_sha1(void)
{
  struct in_out {
    char *in;
    char out[SHA1_HEX_SIZE];
  } in_out[] = {
      {
	  .in  = "",
	  .out = "da39a3ee5e6b4b0d3255bfef95601890afd80709",
      },
      {
	  .in  = "a",
	  .out = "86f7e437faa5a7fce15d1ddcb9eaeaea377667b8",
      },
      {
	  .in  = "abc",
	  .out = "a9993e364706816aba3e25717850c26c9cd0d89d",
      },
      {
	  .in  = "message digest",
	  .out = "c12252ceda8be8994d5fa0290a47231c1d16aae3",
      },
      {
	  .in  = "abcdefghijklmnopqrstuvwxyz",
	  .out = "32d10c7b8cf96570ca04ce37f2a19d84240d3a89",
      },
      {
	  .in  = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",
	  .out = "761c457bf73b14d27e9e9265c46f4b4dda11f940",
      },
      {
	  .in  = "12345678901234567890123456789012345678901234567890123456789012345678901234567890",
	  .out = "50abf5706a150990a08b2c5ea40fa0e585554732",
      },
      {
	  .in  = "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",
	  .out = "6a64fcc1fb970f7339ce886601775d2efea5cd4b",
      },
  };

  bt_assert_fn_in_out(get_sha1, in_out, "'%s'", "'%s'");

  return bt_suite_result;
}

#define HMAC_BUFFER_SIZE 80
struct hmac_data_in {
  byte key[HMAC_BUFFER_SIZE];
  uint key_len;
  byte data[HMAC_BUFFER_SIZE];
  uint data_len;
};

static void
get_sha1_hmac(const struct hmac_data_in in, char (*out_hash)[SHA1_HEX_SIZE])
{
  struct sha1_hmac_context ctx;
  sha1_hmac_init(&ctx, in.key, in.key_len);
  sha1_hmac_update(&ctx, in.data, in.data_len);
  byte *hash_byte = sha1_hmac_final(&ctx);

  int i;
  for (i = 0; i < SHA1_SIZE; i++)
    sprintf(*out_hash + i*2, "%02x", hash_byte[i]);
}

static int
t_sha1_hmac(void)
{
  struct in_out {
    struct hmac_data_in in;
    char out[SHA1_HEX_SIZE];
  } in_out[] = {
      {
	  .in  = {
	      .key = {
		  0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b,
		  0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b,
	      },
	      .key_len = 20,
	      .data = "Hi There",
	      .data_len = 8,
	  },
	  .out = "b617318655057264e28bc0b6fb378c8ef146be00",
      },
      {
	  .in  = {
	      .key = "Jefe",
	      .key_len = 4,
	      .data = "what do ya want for nothing?",
	      .data_len = 28,
	  },
	  .out = "effcdf6ae5eb2fa2d27416d5f184df9c259a7c79",
      },
      {
	  .in  = {
	      .key = {
		  0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		  0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
	      },
	      .key_len = 20,
	      .data = {
		  0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd,
		  0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd,
		  0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd,
		  0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd,
		  0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd,
	      },
	      .data_len = 50,
	  },
	  .out = "125d7342b9ac11cd91a39af48aa17b4f63f175d3",
      },
      {
	  .in  = {
	      .key = {
		  0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a,
		  0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14,
		  0x15, 0x16, 0x17, 0x18, 0x19,
	      },
	      .key_len = 25,
	      .data = {
		  0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd,
		  0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd,
		  0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd,
		  0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd,
		  0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd,
	      },
	      .data_len = 50,
	  },
	  .out = "4c9007f4026250c6bc8414f9bf50c86c2d7235da",
      },
      {
	  .in  = {
	      .key = {
		  0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c,
		  0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c,
	      },
	      .key_len = 20,
	      .data = "Test With Truncation",
	      .data_len = 20,
	  },
	  .out = "4c1a03424b55e07fe7f27be1d58bb9324a9a5a04",
      },
      {
	  .in  = {
	      .key = {
		  0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		  0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		  0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		  0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		  0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		  0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		  0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		  0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
	      },
	      .key_len = 80,
	      .data = "Test Using Larger Than Block-Size Key - Hash Key First",
	      .data_len = 54,
	  },
	  .out = "aa4ae5e15272d00e95705637ce8a3b55ed402112",
      },
      {
	  .in  = {
	      .key = {
		  0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		  0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		  0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		  0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		  0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		  0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		  0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		  0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
	      },
	      .key_len = 80,
	      .data = "Test Using Larger Than Block-Size Key and Larger Than One Block-Size Data",
	      .data_len = 73,
	  },
	  .out = "e8e99d0f45237d786d6bbaa7965c7808bbff1a91",
      },
      {
	  .in  = {
	      .key = {
		  0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		  0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		  0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		  0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		  0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		  0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		  0x61, 0x61, 0x61, 0x61,
	      },
	      .key_len = 64,
	      .data = "Test Using key 64 bytes sized",
	      .data_len = 29,
	  },
	  .out = "a55d4fb80962a6b3d2e720705314bee417d68cf6",
      },
  };

  bt_assert_fn_in_out(get_sha1_hmac, in_out, NULL, "'%s'");

  return BT_SUCCESS;
}

int
main(int argc, char *argv[])
{
  bt_init(argc, argv);

  bt_test_suite(t_sha1, 	"Test Suite by RFC 1321 (it is for MD5)");
  bt_test_suite(t_sha1_hmac, 	"Test Suite by RFC 2202");

  return bt_exit_value();
}

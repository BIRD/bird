/*
 *	BIRD Library -- MD5 and HMAC-MD5 Tests
 *
 *	(c) 2015 CZ.NIC z.s.p.o.
 *
 *	Can be freely distributed and used under the terms of the GNU GPL.
 */

#include "test/birdtest.h"
#include "test/bt-utils.h"

#include "lib/md5.h"

static int
test_md5(void *out_, const void *in_, const void *expected_out_)
{
  char *out = out_;
  const char *in = in_;
  const char *expected_out = expected_out_;
  struct md5_context ctxt;

  md5_init(&ctxt);
  md5_update(&ctxt, in, strlen(in));
  byte *out_bin = md5_final(&ctxt);

  bt_bytes_to_hex(out, out_bin, MD5_SIZE);

  return strncmp(out, expected_out, MD5_HEX_SIZE) == 0 ? BT_SUCCESS : BT_FAILURE;
}

static int
t_md5(void)
{
  struct bt_pair test_vectors[] = {
    {
      .in  = "",
      .out = "d41d8cd98f00b204e9800998ecf8427e",
    },
    {
      .in  = "a",
      .out = "0cc175b9c0f1b6a831c399e269772661",
    },
    {
      .in  = "abc",
      .out = "900150983cd24fb0d6963f7d28e17f72",
    },
    {
      .in  = "message digest",
      .out = "f96b697d7cb7938d525a2f31aaf161d0",
    },
    {
      .in  = "abcdefghijklmnopqrstuvwxyz",
      .out = "c3fcd3d76192e4007dfb496cca67e13b",
    },
    {
      .in  = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",
      .out = "d174ab98d277d9f5a5611c2c9f419d9f",
    },
    {
      .in  = "12345678901234567890123456789012345678901234567890123456789012345678901234567890",
      .out = "57edf4a22be3c955ac49da2e2107b67a",
    },
  };

  return bt_assert_batch(test_vectors, test_md5, bt_fmt_str, bt_fmt_str);
}


/* the data structure in sha_test.c*/
#define HMAC_BUFFER_SIZE 80
struct hmac_data_in {
  byte key[HMAC_BUFFER_SIZE];
  uint key_len;
  byte data[HMAC_BUFFER_SIZE];
  uint data_len;
};

static int
test_md5_hmac(void *out_, const void *in_, const void *expected_out_)
{
  char *out = out_;
  const struct hmac_data_in *in = in_;
  const char *expected_out = expected_out_;

  struct md5_hmac_context ctx;
  md5_hmac_init(&ctx, in->key, in->key_len);
  md5_hmac_update(&ctx, in->data, in->data_len);
  byte *out_bin = md5_hmac_final(&ctx);

  bt_bytes_to_hex(out, out_bin, MD5_SIZE);

  return strncmp(out, expected_out, MD5_HEX_SIZE) == 0 ? BT_SUCCESS : BT_FAILURE;
}

/* the same function in sha_test.c */
static void
hmac_in_fmt(char *buf, size_t size, const void *data_)
{
  int i;
  const struct hmac_data_in *data = data_;

  snprintf(buf, size, "data: ");
  for (i = 0; i < data->data_len; i++)
    snprintf(buf+strlen(buf), size-strlen(buf), bt_is_char(data->data[i]) ? "%c" : " 0x%02x", data->data[i]);

  snprintf(buf+strlen(buf), size-strlen(buf), ", key: ");
  for (i = 0; i < data->key_len; i++)
    snprintf(buf+strlen(buf), size-strlen(buf), bt_is_char(data->key[i]) ? "%c" : " 0x%02x", data->key[i]);
}

static int
t_md5_hmac(void)
{
  struct bt_pair test_vectors[] = {
    {
      .in  = & (struct hmac_data_in) {
	.key = {
	  0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b,
	  0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b,
	},
	.key_len = 16,
	.data = "Hi There",
	.data_len = 8,
      },
      .out = "9294727a3638bb1c13f48ef8158bfc9d",
    },
    {
      .in  = & (struct hmac_data_in) {
	.key = "Jefe",
	.key_len = 4,
	.data = "what do ya want for nothing?",
	.data_len = 28,
      },
      .out = "750c783e6ab0b503eaa86e310a5db738",
    },
    {
      .in  = & (struct hmac_data_in) {
	.key = {
	  0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
	  0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
	},
	.key_len = 16,
	.data = {
	  0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd,
	  0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd,
	  0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd,
	  0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd,
	  0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd,
	},
	.data_len = 50,
      },
      .out = "56be34521d144c88dbb8c733f0e8b3f6",
    },
    {
      .in  = & (struct hmac_data_in) {
	.key = {
	  0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a,
	  0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14,
	  0x15, 0x16, 0x17, 0x18, 0x19,
	},
	.key_len = 25,
	.data = {
	  0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd,
	  0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd,
	  0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd,
	  0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd,
	  0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd,
	},
	.data_len = 50,
      },
      .out = "697eaf0aca3a3aea3a75164746ffaa79",
    },
    {
      .in  = & (struct hmac_data_in) {
	.key = {
	  0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c,
	  0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c,
	},
	.key_len = 16,
	.data = "Test With Truncation",
	.data_len = 20,
      },
      .out = "56461ef2342edc00f9bab995690efd4c",
    },
    {
      .in  = & (struct hmac_data_in) {
	.key = {
	  0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
	  0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
	  0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
	  0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
	  0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
	  0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
	  0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
	  0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
	},
	.key_len = 80,
	.data = "Test Using Larger Than Block-Size Key - Hash Key First",
	.data_len = 54,
      },
      .out = "6b1ab7fe4bd7bf8f0b62e6ce61b9d0cd",
    },
    {
      .in  = & (struct hmac_data_in) {
	.key = {
	  0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
	  0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
	  0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
	  0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
	  0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
	  0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
	  0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
	  0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
	},
	.key_len = 80,
	.data = "Test Using Larger Than Block-Size Key and Larger Than One Block-Size Data",
	.data_len = 73,
      },
      .out = "6f630fad67cda0ee1fb1f562db3aa53e",
    },
  };

  return bt_assert_batch(test_vectors, test_md5_hmac, hmac_in_fmt, bt_fmt_str);
}

int
main(int argc, char *argv[])
{
  bt_init(argc, argv);

  bt_test_suite(t_md5,      "Test Suite by RFC 1321");
  bt_test_suite(t_md5_hmac, "Test Suite by RFC 2202");

  return bt_exit_value();
}
